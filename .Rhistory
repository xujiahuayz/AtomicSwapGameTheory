library(tikzDevice)
library(magrittr)
library(knitr)
library(data.table)
library(ggplot2)
library(shiny)
library(shinythemes)
library(dplyr)
library(readr)
library(mvtnorm)
library(VGAM)
library(sampleSelection)
library(rootSolve)
library(plotly)
opts_chunk$set(#dev='tikz',
fig.path='./figure/',
echo=F, error=F, cache=F, message=F, warning=F,
# results='hide',
autodep=T,
fig.height = 6)
options(stringsAsFactors = F)
par(mar = c(0.5,0.5,0,0), oma = c(1,1,1,0), mgp = c(0.5, 0, 0), cex.axis=.9, cex = 2)
alphas = c(0.2, 0.2) # agent 1 or 2
rs = c(0.01, 0.01) # agent 1 or 2
mu = 0.002
sigma = 0.1
taua = 3
taub = 4
taueps = 1
pt1 = 2 #current price is given, but strike price is to be negotiated
P0s = seq(0.2,3,length.out = 999)
# Utility function
funcutil = function(Price,Time,Suc,agent){
(1+alphas[agent]*Suc)*Price/exp(rs[agent]*Time)
}
# Brownian motion PDF
funcgbmpdf = function(x, Price, Time){
exp(-(
2 * log(x/Price) - (2*mu-sigma^2)*Time
)^2/(8*sigma^2*Time)
)/(
sqrt(2*pi*Time)*x*sigma
)
}
# Brownian motion CDF
funcgbmcdf = function(x, Price, Time){
erfc( # complementary error function erfc
(log(Price/x)+(mu-sigma^2/2)*Time)/(sqrt(2*Time)*sigma)
)/2
}
# Price = 2
# Time = 2
# x = seq(0, 4, 0.01)
# plot(x, funcgbmpdf(x, Price, Time), type = 'l') # checked with mathematica
# plot(x, funcgbmcdf(x, Price, Time), type = 'l') # checked with mathematica
# price lower bound for Alice
pt3thresh = function(P0){
P0/(
(1+alphas[1])*exp((mu-rs[1])*taub+rs[1]*(taua+taueps))
)
}
# expected utility for Bob if continue
funcoptButil2 = function(x, P0){
# probability to be lower than lower bound
p = funcgbmcdf(pt3thresh(P0), x, taub)
(1-p)*funcutil(
P0,taua+taueps,1,2
)+p*funcutil(
x*exp(2*mu*taub),2*taub,0,2
)
}
funcpt2thresh = function(x, P0){
funcoptButil2(x, P0)- x
}
pt2threshs = function(P0){
tempfunc = function(x){funcpt2thresh(x, P0)}
uniroot.all(tempfunc, lower = 0.01, upper = 999, maxiter = 99999, n = 9999)
}
funcoptAutil = function(pt3vs){
funcutil(
pt3vs*exp(mu*taub),taub,1,1)
}
# utility of Alice at t_3 if withdraw
opt2A = function(P0){
funcutil(P0,taua+taueps,0,1)
}
funcAutil2 = function(pt2, P0){
pt3threshv = pt3thresh(P0)
temp = function(pt3){
funcgbmpdf(pt3, pt2, taub) * funcoptAutil(pt3)
}
funcgbmcdf(pt3threshv, pt2, taub) * opt2A(P0) + integrate(temp, pt3threshv, Inf, abs.tol = 0)$value
}
# P0 = P0s[42]
funcAutilcontinue = function(P0){
temp = function(pt2){
funcgbmpdf(pt2, pt1, taua) * funcAutil2(pt2,P0)
}
pt2threshv = pt2threshs(P0)
# gives terribly wrong answer if omitting abs.tol
utilt3 = integrate(Vectorize(temp), pt2threshv[1], pt2threshv[2], abs.tol = 0)$value
probBobwaive = 1-funcgbmcdf(pt2threshv[2], P0, taua) + funcgbmcdf(pt2threshv[1], P0, taua)
utilt3/exp(rs[1]*(taua+taub))+probBobwaive*P0/exp(rs[1]*(2*taua+taub))
}
funcsuccessrate = function(P0){
temp = function(pt2){
funcgbmpdf(pt2, pt1, taua) * funcgbmcdf(pt3threshv, pt2, taub)
}
pt2threshv = pt2threshs(P0)
# gives terribly wrong answer if omitting abs.tol
integrate(Vectorize(temp), pt2threshv[1], pt2threshv[2], abs.tol = 0)$value
}
# P0 = P0s[41]
# pt2threshv = pt2threshs(P0)
# vs = seq(pt2threshv[1],pt2threshv[2], length.out = 9999)
# df = data.table(x=vs, y=Vectorize(temp)(vs))
#
# (df$y %>% sum)*diff(pt2threshv)/9999
# temp = function(pt2){
#     funcgbmpdf(pt2, pt1, taua) * funcAutil2(pt2,P0)
# }
#
# integrate(Vectorize(temp), pt2threshv[1], pt2threshv[2],abs.tol = 0)$value
taua = 3
taub = 4
sigmas = c(0.06, 0.1, 0.14)
utilA0s = list()
validp0s = list()
sucrates = list()
for (i in 1:3){
sigma = sigmas[i]
utilA0 = Vectorize(funcAutilcontinue)(P0s)
utilA0s[[i]] = utilA0
p0boundsind = which(diff(P0s-utilA0 <0)!=0)
validp0 = seq(P0s[p0boundsind[1]], P0s[p0boundsind[2]], length.out = 999)
validp0s[[i]] = validp0
sucrates[[i]] = Vectorize(funcsuccessrate)(validp0)
}
